import com.badlogic.gdx.utils.JsonWriter
import kotlin.jvm.JvmClassMappingKt
import kotlin.jvm.internal.Reflection
import kotlin.reflect.KCallable
import kotlin.reflect.KClass
import kotlin.reflect.KProperty1
import kotlin.reflect.full.KClasses
import kotlin.reflect.jvm.KClassesJvm
import kotlin.reflect.jvm.ReflectJvmMapping
import org.reflections.Reflections
import org.reflections.scanners.SubTypesScanner
import org.reflections.scanners.TypeAnnotationsScanner
import org.reflections.scanners.MethodAnnotationsScanner
import com.badlogic.gdx.utils.JsonValue

import java.lang.annotation.Annotation
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Paths

apply plugin: "kotlin"

sourceCompatibility = 1.7
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

sourceSets.main.java.srcDirs = ["src/"]

static String getJsonName(KCallable<?> member, Annotation annotation) {
    if (annotation.name().blank) {
        return member.name
    } else {
        return annotation.name()
    }
}

static Annotation findSerializationNameAnnotation(KProperty1<?, ?> property) {
    def annotations = ["JsonUpdateSerializable", "JsonFullSerializable", "JsonSaveSerializable"]
    return property.annotations.find { it.annotationType().simpleName in annotations }
}

static String getManualConstructorClass(KClass<?> clazz, Class<? extends Annotation> manualConstructorAnnotation) {
    def companion = KClasses.getCompanionObject(clazz)
    if (companion != null) {
        return KClasses.getDeclaredFunctions(companion).grep {
            it.annotations.any { it.annotationType() == manualConstructorAnnotation }
        }.empty ? null : KClassesJvm.getJvmName(companion)
    }
    return null
}

static Map<String, String> getPropertyJsonNames(KClass<?> clazz) {
    def classes = new ArrayList<KClass<?>>()
    classes.add(clazz)
    classes.addAll(KClasses.getAllSuperclasses(clazz))
    return classes.collect { KClasses.getDeclaredMemberProperties(it) }
            .flatten()
            .collect { it as KProperty1<?, ?> }
            .collect {
                def annotation = findSerializationNameAnnotation(it)
                if (annotation != null) {
                    return new AbstractMap.SimpleImmutableEntry(it, annotation)
                }
                return null
            }
            .grep { it != null }
            .collectEntries {
                new AbstractMap.SimpleImmutableEntry(
                        it.key.name,
                        getJsonName(it.key as KCallable<?>, it.value as Annotation)
                )
            }
}

static List<String> getClassParametersName(KClass<? extends Object> clazz) {
    def propertyJsonNames = getPropertyJsonNames(clazz)
    def constructor = KClasses.getPrimaryConstructor(clazz)
    if (constructor == null) {
        throw new IllegalArgumentException("Class $clazz should have a primary constructor to be serializable")
    }
    constructor.parameters.collect {
        if (it.name == null) {
            throw new IllegalStateException("Reflections cannot be configured without parameter names")
        }
        propertyJsonNames[it.name] ?: it.name
    }
}

static def addSerializationTypeClasses(
        Reflections reflections, JsonValue json,
        Class<? extends Annotation> serializationTypeAnnotation,
        Class<? extends Annotation> manualConstructorAnnotation
) {
    JsonValue serializationTypeClasses = new JsonValue(JsonValue.ValueType.object)
    reflections.getTypesAnnotatedWith(serializationTypeAnnotation)
            .forEach { serializationClass ->
                KClass<?> kSerializationClass = Reflection.createKotlinClass(serializationClass)
                def list = KClasses.getAllSuperclasses(kSerializationClass)
                list.add(kSerializationClass)
                list.forEach { kClass ->
                    def className = KClassesJvm.getJvmName(kClass)
                    if (kClass != kSerializationClass && serializationTypeClasses.has(className)) {
                        return
                    }
                    JsonValue result = new JsonValue(JsonValue.ValueType.object)

                    String manualConstructorObject = getManualConstructorClass(kClass, manualConstructorAnnotation)
                    if (manualConstructorObject != null) {
                        result.addChild("manualConstructorClass", new JsonValue(manualConstructorObject))
                    }

                    if (kClass == kSerializationClass) {
                        JsonValue parametersName
                        parametersName = new JsonValue(JsonValue.ValueType.array)
                        getClassParametersName(kClass)
                                .forEach { parametersName.addChild(new JsonValue(it)) }
                        result.addChild("parametersName", parametersName)
                    }

                    def superclass = kClass.supertypes.collect {
                        if (it.classifier != null) {
                            JvmClassMappingKt.getJavaClass(it.classifier as KClass<? extends Object>)
                        } else {
                            null
                        }
                    }.find { it != null && !it.isInterface() }

                    if (superclass != null) {
                        result.addChild("superclass", new JsonValue(superclass.name))
                    }

                    serializationTypeClasses.remove(className)
                    serializationTypeClasses.addChild(className, result)
                }
            }
    json.addChild("serializationTypeClasses", serializationTypeClasses)
}

static def addSerializationTypeFunctions(
        Reflections reflections, JsonValue json,
        Class<? extends Annotation> serializationTypeAnnotation
) {
    JsonValue serializationTypeFunctions = new JsonValue(JsonValue.ValueType.object)
    def allMethods = reflections.getMethodsAnnotatedWith(serializationTypeAnnotation)
    allMethods.groupBy { it.declaringClass }
            .entrySet()
            .forEach { entry ->
                def classJson = new JsonValue(JsonValue.ValueType.object)
                entry.value.forEach { method ->
                    def methodJson = new JsonValue(JsonValue.ValueType.array)
                    ReflectJvmMapping.getKotlinFunction(method).parameters.collect().tail().forEach {
                        if (it.name == null) {
                            throw new IllegalStateException("Reflections cannot be configured without parameter names")
                        }
                        methodJson.addChild(new JsonValue(it.name as String))
                    }
                    classJson.addChild(method.name, methodJson)
                }
                serializationTypeFunctions.addChild(entry.key.getName(), classJson)
            }
    json.addChild("serializationTypeFunctions", serializationTypeFunctions)
}

static def addMetaInf(ClassLoader classLoader, Reflections reflections, JsonValue json) {
    Class<? extends Annotation> serializationTypeAnnotation =
            classLoader.loadClass("com.company.todd.json.SerializationType") as Class<? extends Annotation>
    Class<? extends Annotation> manualConstructorAnnotation =
            classLoader.loadClass("com.company.todd.json.ManualJsonConstructor") as Class<? extends Annotation>
    addSerializationTypeClasses(reflections, json, serializationTypeAnnotation, manualConstructorAnnotation)
    addSerializationTypeFunctions(reflections, json, serializationTypeAnnotation)
}

task configureReflection {
    dependsOn classes

    doLast {
        List<URL> urlsList = sourceSets.main.runtimeClasspath.files.collect {
            it.exists() ? it.toURI().toURL() : null
        }
        urlsList.removeAll { it == null }
        URL[] urls = urlsList
        ClassLoader classLoader = new URLClassLoader(urls)

        Reflections reflections = new Reflections(
                "com.company.todd",
                urls, classLoader,
                new SubTypesScanner(false),
                new TypeAnnotationsScanner(),
                new MethodAnnotationsScanner()
        )
        JsonValue json = new JsonValue(JsonValue.ValueType.object)
        addMetaInf(classLoader, reflections, json)

        java.nio.file.Path relativePath = Paths.get("META-INF", "my-reflections", "my-reflections.json")
        File file = sourceSets.main.output.classesDirs.asList().get(0)
        Writer writer = null
        try {
            java.nio.file.Path jsonPath = file.toPath().resolve(relativePath)
            Files.createDirectories(jsonPath.parent)
            writer = Files.newBufferedWriter(jsonPath, StandardCharsets.UTF_8)
            writer.write(json.toJson(JsonWriter.OutputType.json))
        } catch (IOException e) {
            throw new java.io.UncheckedIOException(e)
        } finally {
            if (writer != null) {
                writer.close()
            }
        }
    }
}

tasks.findByName("classes").finalizedBy(configureReflection)
